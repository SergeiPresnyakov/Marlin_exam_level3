1. Компонент QueryBuilder

Сначала я определю, какую задачу должен выполнять компонент. Компонент QueryBuilder должен составлять и выполнять SQL-запросы. Подключением к базе этот компонент заниматься не будет, для этого у нас будет отдельный компонент. QueryBuilder будет обрабатывать запросы 6 видов:
	1. Получить все записи из таблицы (getAll)
	2. Получить одну запись по id (getById)
	3. Получить одну или несколко записей по условию (get)
	4. Вставить в таблицу новую запись (insert)
	5. Изменить существующую запись (update)
	6. Удалить запись из таблицы (delete)

Для начала определю как я буду использовать этот компонент. 
$query = new QueryBuilder($pdo);
$result = $query->getAll('users');

Создам класс компонента и метод getAll - он довольно простой и нет смысла описывать его здесь. Подключу копмонент в файле index.php и в нем же создам подключение к базе $pdo = new PDO... Проверю что метод работает так как я задумал.

Метод getById будет получать одну запись из БД, используя уникальный для каждой записи ключ id.
$result = $query->getById('users', 1);
Проверяю что метод работает.

Для метода get, получающего данные по условию, я решаю использовать в качестве аргумента массив where из
трех элементов [поле, отношение, значение]. Мы уже использовли такое на этапе 2
$result = $query->get('users', ['username', '=', 'John Doe']);
Проверяем метод на работоспособность.

Тут я заметил что у меня дублирование кода в той части, которая подготавливает SQL-запрос и выполняет его.
Нужно как-то решить эту проблему. Пусть методы будут строить SQL-запрос в виде шаблона "SELECT * FROM table WHERE field = ?", а потом уже передавать его следующему методу, который подготовит запрос, привяжет значения в места с "?" c помощью метода bindValue, затем выполнять его. Возвращать метод будет $statement, на котором уже выполнен метод execute. Останется только извлечь нужные данные в наших методах getById, getAll, с помощью fetch и fetchAll. Конечные методы будут возвращать результат в виде ассоциативного массива. Назову этот метод query, и он будет иметь модификатор доступа private, посткольку не является частью интерфейса нашего компонента, он нужен как вспомогательный для публичных 6-и методов, определённых выше.

Для методов insert, update и delete запрос может быть по одному или нескольким параметрам, и мы заранее не знаем их количество. Придется формировать SQL-запрос, используя стандартные функции для работы со строками и массивами. И затем уже передавать его методу query. Опять же сталкиваемся с дублированием кода - операции составления запроса во многом повторяются, отличаясь лишь несколькими деталями. Решим это с помощью метода action, который будет обёрткой над query и возьмет на себя формирование сложных запросов, принмая в качестве аргументов имя таблицы, начальную строку SQL-запроса ('SELECT *', 'DELETE') и массив where. Он также будет приватным и будет возвращать результат запроса вызывающим его публичным методам, в виде массива, если метод запрашивал данные или в виде булевского значения, которое означает успешность запроса, если это были методыб изменяющие данные в таблице.

Теперь нужно разобраться с компонентом, который будет заниматься подключением к БД.

2. Компонент Connection

Этот класс не будет сложным. У него будет только одни статичный метод, возвращающий объект PDO - наше подключение к базе. Для этого ему нужны данные для подключения, которые он будет принимать в виде ассоциативного массива.

Конфигурацию вынесу в отдельный файл config.php, где при желании его удобно будет редактировать или просматривать. Массив будет возвращаться напрямую из файла.
$config = include 'config.php';
$pdo = Connection::make($config['database']);
$query = new QueryBuilder($pdo);

или 
$query = new QueryBuilder(Connection::make($config['database']));

Подключение к базе вынесем в отдельный файл dbstart.php, где будут подключаться компоненты Connection и QueryBuilder, а сам объект QueryBuilder будет возвращаться из файла.

3. Компонент Router

Для дальнейшей работы нам нужно несколько страниц, сверстал их с помощью Bootstrap. Немного поменяем структуру проекта - переместим файл index.php из корня проекта в папку public. Это нужно чтобы корень проекта находился в своей папке и никто не получить доступ к файлам, которые находятся уровнем ниже по файловой иерархии. Теперь нужно настроить сервер таким образом чтобы папка public считалась новым корнем проекта. Поскольку я использую Open Server и сервер nginx, то установлю настройки сервера таким образом:

.
.
.
# if ($request_method !~* ^(GET|HEAD|POST)$ ){return 403;}
    location ~ /\. {deny all;}

    location / {
        root       "%hostdir%/public";
        index      index.php index.html index.htm;
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        root                               "%hostdir%/public";
        try_files                          $uri =404;
        # if (!-e $document_root$document_uri){return 404;}
        fastcgi_pass                       backend;
        fastcgi_index                      index.php;
.
.
.

Файл public/index.php будет единственной точкой входа на наш сайт. Адрес страницы будем брать из $_SERVER['REQUEST_URI']. Я хочу чтобы при переходе в корень сайта '/' роутер перенаправлял пользователя по адресу ../pages/mainpage.php. Для этого создадим папку pages, где будут храниться страницы, предназначенные для просмотра пользователем, и в нем файл mainpage.php.

Теперь создам массив с правилами для нашего роутера:
$routes = ['/' => '../pages/mainpage.php'];
и пропишу условие, если адрес, полученный из $_SERVER['REQUEST_URI'] присутствует в routes, то сделаем include файла по адресу, который хранится под этим ключем. Убеждаемся что это работает.

Можно приступать к созданию компонента Router. Создадим файл Router.php в папке Components, где у нас уже лежат Connection.php и QueryBuilder.php. Классу нужно откуда-то получить конфигурацию - массив с правилами для роутера. Прописывать его прямо в классе будет непрактично. Вернемся к файлу config.php, где уже лежит наш конфиг для БД. Допишем правила для роутера прямо в него под ключом 'router'.
Определим как будет использоваться класс:
Router::config($config); // получение конфигурации
Router::page($url); // навигация на нужную страницу

В файле index.php подключим компонент Router и получим конфиги из config.php, там же разместим вышеуказанные два метода. Так должен будет работать наш компонент.
Реализуем метод page. Он будет получать адрес, который приходит из $_SERVER['REQUEST_URI'], и если он есть в списке, полученном из $config, то инклюдит соответствующую ему страницу, а если нет - то на страницу с ошибкой 404. Также нам придется передавать в адресах get-параметры, разумеется мы не можем предусмотреть все возможные параметры и прописать их в конфигах, нужно как-то отделить их от адреса. Для этого воспользуемся функцией parse_url, которая распарсит переданный адрес и вернет результат в виде ассоциативного массива, где под ключем path будет лежать адрес без get-параметров, вне зависимости от того, были ли они изначально. 

Также напишем метод, возвращающий наши конфиги. Может пригодится для отладки.
Наш компонент работает. Отлично!

4. Компонент Flash

Компонент будет работать через глобальный массив $_SESSION, для этого нужно запустить сессию с помощью функции session_start(). Флеш-сообщения будут использоваться на главной странице, а также на страницах создания и редактирования пользователей. На всех этих страницах ведётся работа с БД, так что логично будет включить session_start() в файл dbstart.php.

Компонент будет представлять собой класс со статическими методами. Будет 3 метода:
Flash::set($theme, $message) - установить флеш-сообщение. Требуется указать тему (success, warning, danger) и текст самого сообщения.

Flash::exists($theme) - будет возвращать булевское значение, говорящее о том, установлено ли флеш-сообещние заданной темы

Flash::display($theme) - будет возвращать текст флеш-сообщения заданной темы, а затем сразу удалять его из массива $_SESSION, чтобы сообщение не отображалось после обновления страницы.
Протестируем компонент, выдав флеш-сообшение об успехе при создании нового пользователя.

5. Компонент Validator

Этот компонент должен заниматься проверкой данных, введенных в форме на соответствие заданным правилам.
Реализуем пока проверку 6 правил:
1. required - поле с этим правилом должно быть заполнено, иначе возникает ошибка валидации
2. min - введенные данные не должны быть короче этого значения
3. max - не должны быть длиннее этого значения
4. matches - данные должны совпадать с даннымы в указанном поле
5. unique - эта запись должна быть уникальна в БД
6. email - данные должны соответствовать формату email

Для правила unique компоненту нужно подключение к базе данных. Добавим его в конструктор класса, воспользуемся для этого уже готовыми компонентами QueryBuilder и Connection. 

Зададим классу свойства: passed - булевское значение об успешном прохождении валидации и массив errors для хранения ошибок валидации.

Напишем несколько простых методов:
errors() - геттер, возвращающий список ошибок валидации
passed() - геттер, возвращающий успешность прохождения валидации
addError() - будет добавлять новую запись в массив ошибок. Сделаем его приватным, поскольку он нужен только для работы публичных методов и не является частью интерфейса класса
Основную работу выполняет метод check, он будет принимать в качестве аргументов массив, где хранятся данные из отправленной формы (скорее всего это в большинстве случаев будет глобальный массив $_POST), а также массив с правилами, где хранятся ключи, имя которых соответствует именам полей формы, а под ключами хранятся массивы с правилами для этого поля.

Правило required обрабатывается отдельно от остальных, если поле с этим правилом пустое, то добавляем соответствующую ошибку в массив errors. 

Все непустые поля проверяем на соответствие остальным правилам. Для проверки длинны введенных данных для правил min и max используем функцию mb_strlen(), таким образом правило сработает одинаково для данных введенных и латиницей и кириллицей. Все проверки будут проходить в структуре switch case. Для правила email используем функцию filter_var c константой FILTER_VALIDATE_EMAIL.

Если полсле выполнения проверок массив с ошибками пустой, то значит валидация пройдена успешно.

Также, для того чтобы валидация срабатывала только после отправки формы, нам нужно как-то проконтролировать отправлена ли форма. Воспользуемся для этого компонентом Input, котрый мы использовали на уровне 2. Там будет 2 простых метода: exists - проверка того, отправлена ли форма, и get, котрый вернет нам данные из формы по имени элемента ввода.

Созадим файл-обработчик для создания пользователя create_user.php. В нем вызовем компонент Validator, и введём проверки для полей username и email. Если валидация пройдена успешно, то установим флеш-сообщение об успехе и переведём пользователя на главную страницу, а если нет, то установим сообщение об ошибке валидации и перенаправим обратно на страницу создания пользователя. 

Попробуем намеренно ввести некорректные данные. Сообщение об ошибке валидации появляется, но нам нужно вывести ещё сами ошибки. Поскольку мы находимся уже в другом файле, то у нас нет доступа к экземпляру класса Validator, в котором у нас хранятся ошибки. Нужно как-то включить список ошибок в сам текст сообщения об ошибке.

Я решил написать метод в классе Validator, который из списка ошибок сформирует html-код маркированного списка и вернёт его в виде строки, которую мы сконкатенируем с сообщением об ошибке при задании флеш-сообщения. Назовем метод errors_ul_html. Убеждаюсь что все работает как я задумывал.

Далее я создам возможность редактирования пользователя. Форма редактирования будет повторять форму создания, за исключением нескольких мелких деталей. Поля в форме будут сразу заполнены существующими данными. Создам файл-обработчик edit_user.php. В нем уже задам параметры валидации. Я хочу чтобы email пользователя был уникальным. Если при редактировании пользователя email не поменялся, то валидация не будет пройдена, ведь такой email в базе уже есть. Но это email самого пользователя, поэтому нужно сделать так чтобы валидация email не проводилась в случае если он не поменялся.

Передадим в файл-обработчик id пользователя через get-параметр. Там уже мы запросим из базы существующий email пользователя по id. В правилах валидации сначала пропишем только правила для username, а если полученный из базы email отличается от полученного из формы, то добавим правила и для email.

В отличие от создания нового пользователя мы перенаправляем на страницу редактирования пользователя при любом случае, только с разными флеш-сообщениями.

Удаление пользователя будет производиться нажатием кнопки Delete с запросом подтверждения

